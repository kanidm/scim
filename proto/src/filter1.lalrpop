
use crate::filter::ScimFilter;
use lalrpop_util::ParseError;

// See https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2

grammar;

/*
match {
    r"[a-zA-Z][a-zA-Z0-9\-_]*"
} else {
    r"[a-zA-Z0-9\-_]+",
    _
}
*/

pub(crate) AttrExp: ScimFilter = {
    <a:AttrPath> "pr" => ScimFilter::Present(a),
    <a:AttrPath> "eq" <v:CompValue> => ScimFilter::Equal(a, v),
}

CompValue: serde_json::Value = {
    // For now we have to limit this because I'm not totally sure how to make it work nice.
    // We may need a custom lexer?
    <s:r"[a-zA-Z0-9\-_]+"> =>?
        serde_json::from_str(s)
            .map_err(|_| ParseError::User {
                error: "Failed to parse value as a valid json value."
            })
};

// CompareOp
// Part of the enum

pub(crate) AttrPath: crate::filter::AttrPath = {
    // In the future for rfc we may need to support the uri parser here.
    <a:Aname> <s:SubAttr> => crate::filter::AttrPath { a, s: Some(s) },
    <a:Aname> => crate::filter::AttrPath { a, s: None },
}

SubAttr: String = {
    "." <Aname> => <>,
};


pub(crate) Aname: String = <s:r"[a-zA-Z][a-zA-Z0-9\-_]*"> => String::from(s);
